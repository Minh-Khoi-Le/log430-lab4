# Monitoring Metrics Guide for Stress Testing

This guide explains the metrics dashboards used to monitor application performance during k6 stress tests.

## Overview Dashboard Metrics

### Request Rate Overview

```
sum(rate(http_request_duration_seconds_count{app="log430-server"}[1m])) by (path)
```

**What it shows:** The number of requests per second to each endpoint, allowing you to verify the actual load being generated by k6 tests and identify which endpoints are receiving the most traffic.

### Error Rate Overview

```
sum(rate(http_request_duration_seconds_count{app="log430-server", status_code=~"4.*|5.*"}[1m])) / sum(rate(http_request_duration_seconds_count{app="log430-server"}[1m])) * 100
```

**What it shows:** The percentage of requests resulting in errors (4xx or 5xx status codes). This helps identify when your system begins to fail under load. Values should stay below the 1% threshold defined in k6 config.

### Response Time Overview

```
histogram_quantile(0.95, sum(rate(http_request_duration_seconds_bucket{app="log430-server"}[1m])) by (path, le))
```

**What it shows:** The 95th percentile response time for each endpoint. This indicates if requests are being processed within the acceptable 500ms threshold set in k6 config.

## Authentication Test Metrics (auth-test.js)

### Auth Request Rate

```
rate(http_request_duration_seconds_count{app="log430-server", path=~"/api/v1/users/login"}[1m])
```

**What it shows:** The number of login attempts per second. During the auth test, this should ramp up to match the VU count in the test configuration.

### Auth Response Time

```
histogram_quantile(0.95, sum(rate(http_request_duration_seconds_bucket{app="log430-server", path=~"/api/v1/users/login"}[1m])) by (le))
```

**What it shows:** The time taken for 95% of login requests to complete. Increases here might indicate database connection issues or authentication bottlenecks.

### Auth Success Rate

```
sum(rate(http_request_duration_seconds_count{app="log430-server", path=~"/api/v1/users/login", status_code="200"}[1m])) / sum(rate(http_request_duration_seconds_count{app="log430-server", path=~"/api/v1/users/login"}[1m])) * 100
```

**What it shows:** The percentage of successful logins. A decrease indicates authentication problems under load.

## Product Browsing Metrics (product-test.js)

### Product Listing Request Rate

```
rate(http_request_duration_seconds_count{app="log430-server", path="/api/v1/products", method="GET"}[1m])
```

**What it shows:** The frequency of product listing page views. This will reflect the constant-arrival-rate pattern set in product-test.js.

### Product Detail Request Rate

```
rate(http_request_duration_seconds_count{app="log430-server", path=~"/api/v1/products/[0-9]+", method="GET"}[1m])
```

**What it shows:** The frequency of product detail page views. Useful for tracking the load on individual product data retrieval.

### Product API Response Times Comparison

```
histogram_quantile(0.95, sum(rate(http_request_duration_seconds_bucket{app="log430-server", path=~"/api/v1/products.*"}[1m])) by (path, le)) * 1000
```

**What it shows:** Compares response times between listing and detail endpoints in milliseconds. Product details may take longer due to additional database lookups.

## Cart Operations Metrics (cart-test.js)

### Sales Creation Rate

```
rate(http_request_duration_seconds_count{app="log430-server", path="/api/v1/sales", method="POST"}[1m])
```

**What it shows:** The rate at which new sales (cart additions) are being created. This reflects the load generated by the cart-test.js script.

### Sales API Performance

```
histogram_quantile(0.95, sum(rate(http_request_duration_seconds_bucket{app="log430-server", path="/api/v1/sales", method="POST"}[1m])) by (le)) * 1000
```

**What it shows:** The response time for creating sales in milliseconds. This operation involves multiple tables (sales, products, stock) and is typically more resource-intensive.

### Cart Operation Success Rate

```
sum(rate(http_request_duration_seconds_count{app="log430-server", path="/api/v1/sales", method="POST", status_code=~"2.*"}[1m])) / sum(rate(http_request_duration_seconds_count{app="log430-server", path="/api/v1/sales", method="POST"}[1m])) * 100
```

**What it shows:** The percentage of successful cart operations. A decrease might indicate database constraints being hit or product stock issues.

## System Resource Metrics

### Node.js Event Loop Lag

```
nodejs_eventloop_lag_seconds{app="log430-server"}
```

**What it shows:** How backed up the Node.js event loop is becoming. High values (>50ms) indicate the server is struggling to process requests promptly.

### Memory Usage

```
nodejs_heap_size_used_bytes{app="log430-server"} / 1024 / 1024
```

**What it shows:** The amount of memory being used by the Node.js process in MB. Steadily increasing values may indicate memory leaks.

### CPU Usage

```
rate(process_cpu_seconds_total{app="log430-server"}[1m]) * 100
```

**What it shows:** The percentage of CPU being utilized. High values (>70%) indicate CPU might be a bottleneck.

### Database Connections

```
nodejs_external_memory_bytes{app="log430-server"} / 1024 / 1024
```

**What it shows:** External memory usage, which can reflect database connection pools and other external resources.

## Custom Business Metrics

### Product Operations Count

```
sum(product_operations_total{app="log430-server"}) by (operation, status)
```

**What it shows:** Aggregated counts of product-related operations (create, read, update, delete) by their outcome status. This tracks how the business operations are performing.

### Product List Operations Rate

```
rate(product_operations_total{app="log430-server", operation="list", status="success"}[1m])
```

**What it shows:** How many successful product listing operations occur per second. This should correlate with the GET requests to the products endpoint.

## How to Use These Metrics

1. **Baseline Comparison:** Run tests with low load first to establish baseline metrics
2. **Threshold Monitoring:** Watch for metrics that breach the thresholds set in your k6 config:
   - Response times exceeding 500ms (95th percentile)
   - Error rates exceeding 1%
3. **Bottleneck Identification:** When performance degrades:
   - Check CPU and memory usage first
   - Then check Node.js event loop lag
   - Finally examine database-related metrics
4. **Scaling Decisions:** Use these metrics to determine which components need scaling:
   - High CPU: Add more server instances
   - High memory: Increase memory allocation
   - High database latency: Optimize queries or scale database

